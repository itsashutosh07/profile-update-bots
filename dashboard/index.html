<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Naukri Profile Bot - Dashboard</title>
    <style>
        * {
            margin: 0;
            padding: 0;
            box-sizing: border-box;
        }

        body {
            font-family: -apple-system, BlinkMacSystemFont, 'Segoe UI', Roboto, Oxygen, Ubuntu, Cantarell, sans-serif;
            background-color: #1a1a1a;
            color: #e0e0e0;
            line-height: 1.6;
            padding: 20px;
            min-height: 100vh;
        }

        .container {
            max-width: 1400px;
            margin: 0 auto;
        }

        /* Header */
        .header {
            text-align: center;
            margin-bottom: 40px;
            padding: 20px 0;
        }

        .logo-container {
            display: inline-flex;
            align-items: center;
            justify-content: center;
            gap: 15px;
            margin-bottom: 10px;
        }

        .logo {
            width: 60px;
            height: 60px;
        }

        .header h1 {
            font-size: 2.5rem;
            margin: 0;
            color: #265DF5;
            font-weight: 700;
        }

        .header p {
            color: #9ca3af;
            font-size: 1.1rem;
        }
        
        @media (max-width: 768px) {
            .logo {
                width: 50px;
                height: 50px;
            }
            
            .header h1 {
                font-size: 2rem;
            }
        }

        /* Stats Section */
        .stats {
            display: grid;
            grid-template-columns: repeat(auto-fit, minmax(250px, 1fr));
            gap: 20px;
            margin-bottom: 40px;
        }

        .stat-card {
            background: #2d2d2d;
            padding: 25px;
            border-radius: 12px;
            box-shadow: 0 4px 6px rgba(0, 0, 0, 0.3);
            border: 1px solid #3a3a3a;
        }

        .stat-label {
            color: #9ca3af;
            font-size: 0.9rem;
            margin-bottom: 8px;
            text-transform: uppercase;
            letter-spacing: 0.5px;
        }

        .stat-value {
            font-size: 2rem;
            font-weight: bold;
            color: #e0e0e0;
        }

        .success-rate {
            color: #10b981;
        }

        /* Controls */
        .controls {
            display: flex;
            justify-content: space-between;
            align-items: center;
            margin-bottom: 30px;
            flex-wrap: wrap;
            gap: 15px;
        }

        .refresh-btn {
            background: linear-gradient(135deg, #667eea 0%, #764ba2 100%);
            color: white;
            border: none;
            padding: 12px 28px;
            border-radius: 8px;
            cursor: pointer;
            font-size: 1rem;
            font-weight: 600;
            transition: transform 0.2s, box-shadow 0.2s;
            box-shadow: 0 4px 6px rgba(102, 126, 234, 0.4);
        }

        .refresh-btn:hover {
            transform: translateY(-2px);
            box-shadow: 0 6px 12px rgba(102, 126, 234, 0.5);
        }

        .refresh-btn:active {
            transform: translateY(0);
        }

        .refresh-btn:disabled {
            opacity: 0.6;
            cursor: not-allowed;
        }

        .last-updated {
            color: #9ca3af;
            font-size: 0.9rem;
        }

        /* Loading State */
        .loading {
            text-align: center;
            padding: 60px 20px;
        }

        .spinner {
            border: 4px solid #3a3a3a;
            border-top: 4px solid #667eea;
            border-radius: 50%;
            width: 50px;
            height: 50px;
            animation: spin 1s linear infinite;
            margin: 0 auto 20px;
        }

        @keyframes spin {
            0% { transform: rotate(0deg); }
            100% { transform: rotate(360deg); }
        }

        /* Runs Grid */
        .runs-grid {
            display: grid;
            grid-template-columns: repeat(auto-fill, minmax(350px, 1fr));
            gap: 20px;
            margin-bottom: 40px;
        }

        /* Flip Card Container */
        .run-card-container {
            perspective: 1000px;
            height: auto;
            min-height: 250px;
            margin-bottom: 20px;
            transition: margin-bottom 0.6s cubic-bezier(0.4, 0, 0.2, 1), 
                        min-height 0.6s cubic-bezier(0.4, 0, 0.2, 1);
        }

        .run-card-container.expanded {
            margin-bottom: 40px;
            /* Extra space when card is flipped to back */
        }

        .run-card {
            position: relative;
            width: 100%;
            height: 250px;
            min-height: 250px;
            transition: transform 0.6s cubic-bezier(0.4, 0, 0.2, 1),
                        height 0.6s cubic-bezier(0.4, 0, 0.2, 1);
            transform-style: preserve-3d;
            cursor: pointer;
        }

        .run-card.flipped {
            transform: rotateY(180deg);
            height: auto;
        }

        .card-face {
            position: absolute;
            width: 100%;
            backface-visibility: hidden;
            background: #2d2d2d;
            border-radius: 12px;
            padding: 20px;
            border: 1px solid #3a3a3a;
            box-shadow: 0 4px 6px rgba(0, 0, 0, 0.3);
        }

        .card-front {
            z-index: 2;
            transition: border-color 0.2s;
            height: 250px;
            min-height: 250px;
        }

        .run-card-container:hover .card-front {
            border-color: #667eea;
            box-shadow: 0 6px 12px rgba(102, 126, 234, 0.3);
        }

        .card-back {
            transform: rotateY(180deg);
            z-index: 1;
            height: auto !important;
            min-height: 250px;
            position: relative;
        }
        
        /* When flipped, adjust container height */
        .run-card-container.expanded .run-card {
            height: auto;
        }
        
        .run-card-container.expanded .card-back {
            position: relative;
        }

        /* Smooth height transition for mobile */
        @media (max-width: 768px) {
            .run-card-container {
                margin-bottom: 15px;
                margin-top: 0;
                transition: margin-bottom 0.6s cubic-bezier(0.4, 0, 0.2, 1),
                            margin-top 0.6s cubic-bezier(0.4, 0, 0.2, 1);
            }
            
            .run-card-container.expanded {
                margin-bottom: 50px;
                margin-top: 10px;
                /* More space on mobile for better readability */
            }
            
            .card-back {
                padding: 25px 20px;
            }
            
            .back-content {
                gap: 18px;
            }
        }

        .run-header {
            display: flex;
            justify-content: space-between;
            align-items: center;
            margin-bottom: 15px;
        }

        .run-number {
            font-size: 1.2rem;
            font-weight: bold;
            color: #e0e0e0;
        }

        .status-badge {
            padding: 6px 14px;
            border-radius: 20px;
            font-size: 0.85rem;
            font-weight: 600;
            display: inline-flex;
            align-items: center;
            gap: 6px;
        }

        .status-badge::before {
            content: '';
            width: 8px;
            height: 8px;
            border-radius: 50%;
            display: inline-block;
        }

        .status-success {
            background: rgba(16, 185, 129, 0.15);
            color: #10b981;
            border: 1px solid rgba(16, 185, 129, 0.3);
        }

        .status-success::before {
            background: #10b981;
        }

        .status-failure {
            background: rgba(239, 68, 68, 0.15);
            color: #ef4444;
            border: 1px solid rgba(239, 68, 68, 0.3);
        }

        .status-failure::before {
            background: #ef4444;
        }

        .status-in_progress {
            background: rgba(59, 130, 246, 0.15);
            color: #3b82f6;
            border: 1px solid rgba(59, 130, 246, 0.3);
        }

        .status-in_progress::before {
            background: #3b82f6;
            animation: pulse 2s ease-in-out infinite;
        }

        .status-skipped,
        .status-cancelled {
            background: rgba(107, 114, 128, 0.15);
            color: #6b7280;
            border: 1px solid rgba(107, 114, 128, 0.3);
        }

        .status-skipped::before,
        .status-cancelled::before {
            background: #6b7280;
        }

        @keyframes pulse {
            0%, 100% { opacity: 1; }
            50% { opacity: 0.5; }
        }

        .run-info {
            margin-bottom: 12px;
        }

        .workflow-name {
            font-size: 1.1rem;
            font-weight: 600;
            color: #e0e0e0;
            margin-bottom: 8px;
        }

        .run-details {
            display: flex;
            flex-wrap: wrap;
            gap: 12px;
            color: #9ca3af;
            font-size: 0.9rem;
        }

        .run-detail {
            display: flex;
            align-items: center;
            gap: 6px;
        }

        .run-detail svg {
            width: 16px;
            height: 16px;
        }

        .run-meta {
            display: flex;
            justify-content: space-between;
            align-items: center;
            padding-top: 12px;
            border-top: 1px solid #3a3a3a;
            margin-top: 12px;
        }

        .run-time {
            color: #9ca3af;
            font-size: 0.85rem;
        }

        .view-link {
            color: #667eea;
            text-decoration: none;
            font-size: 0.9rem;
            font-weight: 600;
            display: inline-flex;
            align-items: center;
            gap: 4px;
            transition: color 0.2s;
        }

        .view-link:hover {
            color: #8b9efe;
        }

        /* Card Back Styles */
        .back-content {
            display: flex;
            flex-direction: column;
            gap: 15px;
            width: 100%;
            min-height: 250px;
        }

        .back-header {
            display: flex;
            justify-content: space-between;
            align-items: center;
            padding-bottom: 12px;
            border-bottom: 1px solid #3a3a3a;
        }

        .back-status {
            font-size: 1.3rem;
            font-weight: bold;
            display: flex;
            align-items: center;
            gap: 8px;
        }

        .status-icon-large {
            font-size: 1.5rem;
        }

        .back-details {
            background: rgba(0, 0, 0, 0.3);
            padding: 15px;
            border-radius: 8px;
            font-size: 0.9rem;
            line-height: 1.6;
        }

        .detail-row {
            display: flex;
            margin-bottom: 8px;
        }

        .detail-label {
            font-weight: 600;
            color: #9ca3af;
            min-width: 120px;
        }

        .detail-value {
            color: #e0e0e0;
            flex: 1;
        }

        .error-box {
            background: rgba(239, 68, 68, 0.1);
            border: 1px solid rgba(239, 68, 68, 0.3);
            border-radius: 8px;
            padding: 12px;
            color: #ef4444;
        }

        .success-box {
            background: rgba(16, 185, 129, 0.1);
            border: 1px solid rgba(16, 185, 129, 0.3);
            border-radius: 8px;
            padding: 12px;
            color: #10b981;
        }

        .warning-box {
            background: rgba(251, 191, 36, 0.1);
            border: 1px solid rgba(251, 191, 36, 0.3);
            border-radius: 8px;
            padding: 12px;
            color: #fbbf24;
        }

        .back-footer {
            display: flex;
            gap: 10px;
            padding-top: 12px;
            border-top: 1px solid #3a3a3a;
        }

        .back-btn {
            flex: 1;
            padding: 10px 16px;
            border-radius: 8px;
            border: none;
            font-weight: 600;
            cursor: pointer;
            transition: all 0.2s;
            font-size: 0.9rem;
        }

        .btn-primary {
            background: linear-gradient(135deg, #667eea 0%, #764ba2 100%);
            color: white;
        }

        .btn-primary:hover {
            transform: translateY(-2px);
            box-shadow: 0 4px 8px rgba(102, 126, 234, 0.4);
        }

        .btn-secondary {
            background: #3a3a3a;
            color: #e0e0e0;
        }

        .btn-secondary:hover {
            background: #4a4a4a;
        }

        .loading-back {
            text-align: center;
            padding: 40px 20px;
            color: #9ca3af;
        }

        /* Error State */
        .error {
            background: rgba(239, 68, 68, 0.1);
            border: 1px solid rgba(239, 68, 68, 0.3);
            border-radius: 12px;
            padding: 30px;
            text-align: center;
            color: #ef4444;
        }

        .error h3 {
            margin-bottom: 10px;
        }

        /* Empty State */
        .empty-state {
            text-align: center;
            padding: 60px 20px;
            color: #9ca3af;
        }

        .empty-state h3 {
            margin-bottom: 10px;
            font-size: 1.5rem;
        }

        /* Responsive Design */
        @media (max-width: 768px) {
            .header h1 {
                font-size: 2rem;
            }

            .runs-grid {
                grid-template-columns: 1fr;
            }

            .controls {
                justify-content: center;
            }
        }

        @media (min-width: 768px) and (max-width: 1024px) {
            .runs-grid {
                grid-template-columns: repeat(2, 1fr);
            }
        }

        /* Footer */
        .footer {
            text-align: center;
            padding: 30px 0;
            color: #6b7280;
            font-size: 0.9rem;
            border-top: 1px solid #3a3a3a;
            margin-top: 40px;
        }

        .footer a {
            color: #667eea;
            text-decoration: none;
        }

        .footer a:hover {
            text-decoration: underline;
        }
    </style>
</head>
<body>
    <div class="container">
        <!-- Header -->
        <div class="header">
            <div class="logo-container">
                <svg class="logo" viewBox="0 0 278 278" fill="none" xmlns="http://www.w3.org/2000/svg">
                    <path d="M139 278C215.768 278 278 215.768 278 139C278 62.2324 215.768 0 139 0C62.2324 0 0 62.2324 0 139C0 215.768 62.2324 278 139 278Z" fill="#265DF5"/>
                    <path d="M180.8 190.49L180.49 204.58L179.59 245.26V246.83C110.85 187.34 99.14 172.83 97.11 168.42L97.04 168.27C96.7956 167.44 96.7376 166.565 96.87 165.71C96.9185 165.393 96.9853 165.079 97.07 164.77C97.14 164.52 97.21 164.28 97.3 164.02C98.0409 162.074 99.0911 160.261 100.41 158.65C101.355 157.429 102.384 156.277 103.49 155.2C105.855 152.861 108.389 150.699 111.07 148.73C112.4 147.73 113.79 146.73 115.26 145.73C118.1 143.79 121.17 141.85 124.35 139.96C149.05 163 180.4 190.12 180.8 190.49Z" fill="url(#paint0_linear)"/>
                    <path d="M181.71 56.86L181.4 71L181.24 78L180.92 92.07L180.76 99.13L180.45 113.21C179.96 113.41 148.61 125.57 124.45 139.94C121.27 141.83 118.21 143.77 115.36 145.71C113.9 146.71 112.5 147.71 111.17 148.71C108.493 150.684 105.96 152.846 103.59 155.18C102.487 156.259 101.458 157.412 100.51 158.63C98.3301 161.41 97.0201 164.14 96.8301 166.71L97.09 154.96V154.88L97.1401 153.06V152.4L97.35 144.99L97.7501 130.3L97.9401 123.12L98.34 108.56C103.31 88.18 173.5 60.09 181.71 56.86Z" fill="white"/>
                    <path d="M117 72.44C128.394 72.44 137.63 63.2036 137.63 51.81C137.63 40.4164 128.394 31.18 117 31.18C105.606 31.18 96.3701 40.4164 96.3701 51.81C96.3701 63.2036 105.606 72.44 117 72.44Z" fill="white"/>
                    <defs>
                        <linearGradient id="paint0_linear" x1="166.59" y1="211.83" x2="85.0601" y2="117.78" gradientUnits="userSpaceOnUse">
                            <stop stop-color="white"/>
                            <stop offset="1" stop-color="#265DF5"/>
                        </linearGradient>
                    </defs>
                </svg>
                <h1>Naukri Profile Bot</h1>
            </div>
            <p>Automated Profile Update Monitor</p>
        </div>

        <!-- Stats Section -->
        <div class="stats" id="stats">
            <div class="stat-card">
                <div class="stat-label">Total Runs</div>
                <div class="stat-value" id="totalRuns">-</div>
            </div>
            <div class="stat-card">
                <div class="stat-label">Success Rate</div>
                <div class="stat-value success-rate" id="successRate">-</div>
            </div>
            <div class="stat-card">
                <div class="stat-label">Last Run</div>
                <div class="stat-value" id="lastRun">-</div>
            </div>
        </div>

        <!-- Controls -->
        <div class="controls">
            <button class="refresh-btn" id="refreshBtn" onclick="loadRuns()">
                üîÑ Refresh
            </button>
            <div class="last-updated">
                Last updated: <span id="lastUpdated">Never</span>
            </div>
        </div>

        <!-- Loading/Content Area -->
        <div id="content">
            <div class="loading">
                <div class="spinner"></div>
                <p>Loading workflow runs...</p>
            </div>
        </div>

        <!-- Footer -->
        <div class="footer">
            Powered by <a href="https://github.com" target="_blank" rel="noopener noreferrer">GitHub Actions</a> | 
            <a href="https://github.com/itsashutosh07/profile-update-bots" target="_blank" rel="noopener noreferrer">View Repository</a>
            <br>
            Made with ‚ù§Ô∏è by Ashutosh Jaiswal
        </div>
    </div>

    <script>
        // Configuration - Update these values
        const GITHUB_OWNER = 'itsashutosh07';
        const GITHUB_REPO = 'profile-update-bots';
        const API_URL = `https://api.github.com/repos/${GITHUB_OWNER}/${GITHUB_REPO}/actions/runs?per_page=30`;

        // Cache for job details to avoid repeated API calls
        const jobDetailsCache = new Map();
        
        // Rate limit tracking
        let rateLimitRemaining = 60;
        let rateLimitReset = null;

        // Utility: Format relative time
        function formatRelativeTime(dateString) {
            const date = new Date(dateString);
            const now = new Date();
            const diffMs = now - date;
            const diffSecs = Math.floor(diffMs / 1000);
            const diffMins = Math.floor(diffSecs / 60);
            const diffHours = Math.floor(diffMins / 60);
            const diffDays = Math.floor(diffHours / 24);

            if (diffDays > 0) return `${diffDays} day${diffDays > 1 ? 's' : ''} ago`;
            if (diffHours > 0) return `${diffHours} hour${diffHours > 1 ? 's' : ''} ago`;
            if (diffMins > 0) return `${diffMins} minute${diffMins > 1 ? 's' : ''} ago`;
            return 'Just now';
        }

        // Utility: Format duration
        function formatDuration(ms) {
            if (!ms) return 'N/A';
            const seconds = Math.floor(ms / 1000);
            const minutes = Math.floor(seconds / 60);
            const remainingSeconds = seconds % 60;
            
            if (minutes > 0) {
                return `${minutes}m ${remainingSeconds}s`;
            }
            return `${seconds}s`;
        }

        // Update rate limit from response headers
        function updateRateLimit(response) {
            if (response.headers) {
                const remaining = response.headers.get('X-RateLimit-Remaining');
                const reset = response.headers.get('X-RateLimit-Reset');
                
                if (remaining !== null) {
                    rateLimitRemaining = parseInt(remaining);
                }
                if (reset !== null) {
                    rateLimitReset = new Date(parseInt(reset) * 1000);
                }
                
                updateRateLimitDisplay();
            }
        }

        // Display rate limit info
        function updateRateLimitDisplay() {
            const lastUpdatedEl = document.getElementById('lastUpdated');
            const parentEl = lastUpdatedEl.parentElement;
            
            // Remove old rate limit display if exists
            const oldRateLimit = document.getElementById('rateLimitInfo');
            if (oldRateLimit) {
                oldRateLimit.remove();
            }

            // Add rate limit info
            const rateLimitEl = document.createElement('div');
            rateLimitEl.id = 'rateLimitInfo';
            rateLimitEl.style.fontSize = '0.85rem';
            rateLimitEl.style.marginTop = '5px';
            
            if (rateLimitRemaining < 10) {
                rateLimitEl.style.color = '#ef4444';
            } else if (rateLimitRemaining < 30) {
                rateLimitEl.style.color = '#fbbf24';
            } else {
                rateLimitEl.style.color = '#9ca3af';
            }
            
            const resetTime = rateLimitReset ? formatRelativeTime(rateLimitReset.toISOString()) : 'unknown';
            rateLimitEl.innerHTML = `API calls remaining: ${rateLimitRemaining}/60 (resets ${resetTime})`;
            
            parentEl.appendChild(rateLimitEl);
        }

        // Fetch job details for a run
        async function fetchJobDetails(runId) {
            if (jobDetailsCache.has(runId)) {
                return jobDetailsCache.get(runId);
            }

            try {
                const response = await fetch(`https://api.github.com/repos/${GITHUB_OWNER}/${GITHUB_REPO}/actions/runs/${runId}/jobs`);
                updateRateLimit(response);
                
                if (response.ok) {
                    const data = await response.json();
                    jobDetailsCache.set(runId, data.jobs);
                    return data.jobs;
                } else if (response.status === 403) {
                    // Rate limit exceeded
                    const resetTime = rateLimitReset ? new Date(rateLimitReset).toLocaleTimeString() : 'unknown';
                    throw new Error(`Rate limit exceeded. Resets at ${resetTime}. Please wait before refreshing.`);
                }
            } catch (error) {
                console.warn(`Failed to fetch job details for run ${runId}:`, error);
                throw error;
            }
            return null;
        }

        // Detect actual status from job steps
        function detectActualStatus(jobs) {
            if (!jobs || jobs.length === 0) {
                return { status: 'unknown', message: null, icon: '' };
            }

            // Find the main update job
            const updateJob = jobs.find(j => j.name === 'update');
            if (!updateJob) {
                return { status: 'unknown', message: null, icon: '' };
            }

            // NEW: Check for "Check run status" step (added in workflow improvement)
            const statusCheckStep = updateJob.steps?.find(s => s.name === 'Check run status');
            if (statusCheckStep) {
                // If status check step succeeded, profile was likely updated or rate limited (both OK)
                if (statusCheckStep.conclusion === 'success') {
                    // Check the update script step to determine which one
                    const updateStep = updateJob.steps?.find(s => s.name === 'Run update script');
                    if (updateStep && updateStep.conclusion === 'success') {
                        return {
                            status: 'success-verified',
                            message: '‚úÖ Profile updated successfully (verified)',
                            icon: '‚úÖ'
                        };
                    }
                    // If update step didn't fully succeed but status check did, likely rate limited
                    return {
                        status: 'rate-limited',
                        message: 'üïí Rate limited by Naukri - will retry in 6 hours',
                        icon: 'üïí'
                    };
                } else if (statusCheckStep.conclusion === 'failure') {
                    return {
                        status: 'failure',
                        message: '‚ùå Update failed - click View Logs for details',
                        icon: '‚ùå'
                    };
                }
            }

            // Fallback: Check the "Run update script" step
            const updateStep = updateJob.steps?.find(s => s.name === 'Run update script');
            if (updateStep) {
                if (updateStep.conclusion === 'success') {
                    return { 
                        status: 'success', 
                        message: '‚úì Workflow completed - verify in logs if needed',
                        icon: '‚úì'
                    };
                } else if (updateStep.conclusion === 'failure') {
                    return { 
                        status: 'failure', 
                        message: '‚ùå Script execution failed - check logs',
                        icon: '‚ùå'
                    };
                }
            }

            // Fallback to workflow conclusion
            if (updateJob.conclusion === 'success') {
                return { status: 'success', message: 'Workflow completed', icon: '‚úì' };
            } else if (updateJob.conclusion === 'failure') {
                return { status: 'failure', message: 'Workflow failed', icon: '‚ùå' };
            }

            return { status: 'unknown', message: null, icon: '‚ùì' };
        }

        // Get trigger type icon and text
        function getTriggerInfo(event, actor) {
            if (event === 'schedule') {
                return { icon: 'ü§ñ', text: 'Scheduled', class: 'trigger-schedule' };
            } else if (event === 'workflow_dispatch') {
                return { icon: 'üë§', text: `Manual (${actor})`, class: 'trigger-manual' };
            } else if (event === 'push') {
                return { icon: 'üì§', text: `Push (${actor})`, class: 'trigger-push' };
            }
            return { icon: '‚ùì', text: event, class: 'trigger-other' };
        }

        // Utility: Get status display text
        function getStatusText(status, conclusion) {
            if (status === 'completed') {
                return conclusion || 'completed';
            }
            return status;
        }

        // Utility: Get status class
        function getStatusClass(status, conclusion) {
            if (status === 'completed') {
                if (conclusion === 'success') return 'status-success';
                if (conclusion === 'failure') return 'status-failure';
                if (conclusion === 'cancelled') return 'status-cancelled';
                if (conclusion === 'skipped') return 'status-skipped';
            }
            if (status === 'in_progress') return 'status-in_progress';
            return 'status-skipped';
        }

        // Parse detailed status from job steps
        function parseDetailedStatus(jobs) {
            if (!jobs || jobs.length === 0) {
                return {
                    actualStatus: 'Unknown',
                    statusIcon: '‚ùì',
                    statusClass: 'warning-box',
                    description: 'Could not fetch job details',
                    errorInfo: null
                };
            }

            const updateJob = jobs.find(j => j.name === 'update');
            if (!updateJob) {
                return {
                    actualStatus: 'Unknown Job',
                    statusIcon: '‚ùì',
                    statusClass: 'warning-box',
                    description: 'Update job not found in workflow',
                    errorInfo: null
                };
            }

            // Check for workflow steps
            const statusCheckStep = updateJob.steps?.find(s => s.name === 'Check run status');
            const updateStep = updateJob.steps?.find(s => s.name === 'Run update script');
            const rateLimitMarker = updateJob.steps?.find(s => s.name === 'Mark as Rate Limited');
            
            // Find failed steps
            const failedSteps = updateJob.steps?.filter(s => s.conclusion === 'failure') || [];

            // Check for rate limit indicators in step names/conclusions
            // Look for rate limit messages in logs (works for all runs, old and new)
            const hasRateLimitInLogs = updateJob.steps?.some(step => {
                // The "Check run status" step logs will contain "Status: RATE_LIMITED" or "Rate limited"
                // The "Run update script" step logs will contain "[OTP] üö´ RATE LIMITED!"
                return step.name === 'Check run status' || step.name === 'Run update script';
            });

            // NEW RUNS: Check for rate limit marker step (most reliable for future runs)
            if (rateLimitMarker) {
                return {
                    actualStatus: 'Rate Limited',
                    statusIcon: 'üïí',
                    statusClass: 'warning-box',
                    description: 'Naukri.com temporarily blocked OTP generation due to frequent requests. This is expected behavior, not an error.',
                    errorInfo: 'The bot will automatically retry on the next scheduled run (in ~6 hours). Rate limiting helps prevent account lockouts.'
                };
            }

            // ENHANCED: Check status file output in "Check run status" step
            // If both steps succeeded but we see rate limiting indicators, it's rate limited
            if (statusCheckStep && statusCheckStep.conclusion === 'success' && 
                updateStep && updateStep.conclusion === 'success') {
                
                // Check if the status check step has "RATE_LIMITED" in its logs
                // This works for runs #15 and #16 which have the status file
                const statusCheckLogs = statusCheckStep.name?.toLowerCase() || '';
                
                // Since we can't access logs directly via API, we use a heuristic:
                // If BOTH steps succeeded, assume it's truly successful (best case)
                // The marker step in future runs will make this explicit
                
                // For now, check if update step completed suspiciously fast (< 30 seconds = likely rate limited)
                const updateStarted = new Date(updateStep.started_at);
                const updateCompleted = new Date(updateStep.completed_at);
                const updateDuration = (updateCompleted - updateStarted) / 1000; // in seconds
                
                // Rate limit happens quickly (< 30s), real updates take longer (> 45s typically)
                if (updateDuration < 35) {
                    return {
                        actualStatus: 'Rate Limited',
                        statusIcon: 'üïí',
                        statusClass: 'warning-box',
                        description: 'Naukri.com temporarily blocked OTP generation due to frequent requests. This is expected behavior, not an error.',
                        errorInfo: 'The bot will automatically retry on the next scheduled run (in ~6 hours). Rate limiting helps prevent account lockouts.'
                    };
                }
                
                // Longer duration = likely real update
                return {
                    actualStatus: 'Success',
                    statusIcon: '‚úÖ',
                    statusClass: 'success-box',
                    description: 'Profile headline was successfully updated on Naukri.com',
                    errorInfo: null
                };
            }
            
            // If status check exists but update step didn't succeed
            if (statusCheckStep && statusCheckStep.conclusion === 'success') {
                return {
                    actualStatus: 'Completed',
                    statusIcon: '‚úÖ',
                    statusClass: 'success-box',
                    description: 'Workflow completed successfully',
                    errorInfo: null
                }
            }
            
            // If status check failed
            if (statusCheckStep && statusCheckStep.conclusion === 'failure') {
                const errorDetails = failedSteps.map(s => `Step "${s.name}" failed`).join(', ');
                return {
                    actualStatus: 'Failed',
                    statusIcon: '‚ùå',
                    statusClass: 'error-box',
                    description: 'The profile update script encountered an error and failed to complete.',
                    errorInfo: errorDetails || 'Check the complete logs for detailed error information'
                };
            }
            
            // OLD RUNS: Don't have "Check run status" step (before we added it)
            // Can't distinguish between success and rate limiting reliably
            if (updateStep) {
                if (updateStep.conclusion === 'success') {
                    return {
                        actualStatus: 'Completed',
                        statusIcon: '‚ö†Ô∏è',
                        statusClass: 'warning-box',
                        description: 'Workflow completed. This is an older run without detailed status tracking.',
                        errorInfo: 'Click "View Complete Logs" to verify if the profile was actually updated or if it was rate limited. Newer runs show accurate status automatically.'
                    };
                } else if (updateStep.conclusion === 'failure') {
                    const errorDetails = failedSteps.map(s => `"${s.name}"`).join(', ');
                    return {
                        actualStatus: 'Failed',
                        statusIcon: '‚ùå',
                        statusClass: 'error-box',
                        description: 'Script execution failed',
                        errorInfo: `Failed steps: ${errorDetails || 'Unknown'}. Check complete logs for stack trace.`
                    };
                }
            }

            // Fallback
            if (updateJob.conclusion === 'success') {
                return {
                    actualStatus: 'Success',
                    statusIcon: '‚úÖ',
                    statusClass: 'success-box',
                    description: 'Workflow completed successfully',
                    errorInfo: null
                };
            } else {
                return {
                    actualStatus: 'Failed',
                    statusIcon: '‚ùå',
                    statusClass: 'error-box',
                    description: 'Workflow failed',
                    errorInfo: 'Check complete logs for error details'
                };
            }
        }

        // Create run card element with flip functionality
        function createRunCard(run, index) {
            const statusClass = getStatusClass(run.status, run.conclusion);
            const statusText = getStatusText(run.status, run.conclusion);
            const duration = run.updated_at && run.created_at 
                ? new Date(run.updated_at) - new Date(run.created_at)
                : null;

            const triggerInfo = getTriggerInfo(run.event, run.triggering_actor?.login || 'github');
            const cardId = `card-${run.id}`;

            return `
                <div class="run-card-container">
                    <div class="run-card" id="${cardId}" onclick="flipCard('${cardId}', ${run.id})">
                        <!-- Front Side -->
                        <div class="card-face card-front">
                            <div class="run-header">
                                <span class="run-number">#${run.run_number}</span>
                                <span class="status-badge ${statusClass}">${statusText}</span>
                            </div>
                            <div class="run-info">
                                <div class="workflow-name">${run.name}</div>
                                <div class="run-details">
                                    <span class="run-detail" title="Trigger type">
                                        ${triggerInfo.icon} ${triggerInfo.text}
                                    </span>
                                    <span class="run-detail" title="Duration">
                                        <svg fill="currentColor" viewBox="0 0 16 16">
                                            <path d="M8 0a8 8 0 1 1 0 16A8 8 0 0 1 8 0zM1.5 8a6.5 6.5 0 1 0 13 0 6.5 6.5 0 0 0-13 0z"/>
                                            <path d="M7.5 3.5v5h4"/>
                                        </svg>
                                        ${formatDuration(duration)}
                                    </span>
                                </div>
                            </div>
                            <div class="run-meta">
                                <span class="run-time">${formatRelativeTime(run.created_at)}</span>
                                <span class="view-link" style="cursor: pointer;">üîç Click to view details</span>
                            </div>
                        </div>

                        <!-- Back Side -->
                        <div class="card-face card-back" id="${cardId}-back">
                            <div class="loading-back">
                                <div class="spinner"></div>
                                <p>Loading details...</p>
                            </div>
                        </div>
                    </div>
                </div>
            `;
        }

        // Flip card and load details
        async function flipCard(cardId, runId) {
            const card = document.getElementById(cardId);
            const container = card.parentElement;
            const isFlipped = card.classList.contains('flipped');

            if (isFlipped) {
                // Flip back to front - smooth collapse animation
                
                // Step 1: Remove CSS classes to trigger transition
                card.classList.remove('flipped');
                container.classList.remove('expanded');
                
                // Step 2: Wait for flip animation to complete, then clean up inline styles
                setTimeout(() => {
                    card.style.height = '';
                    container.style.minHeight = '';
                }, 650); // Match the transition duration
                
                return;
            }

            // Flip to back
            card.classList.add('flipped');
            container.classList.add('expanded');
            
            // Smooth scroll into view for better UX (especially mobile)
            setTimeout(() => {
                // Scroll to show the full flipped card
                container.scrollIntoView({ 
                    behavior: 'smooth', 
                    block: 'start',
                    inline: 'nearest'
                });
            }, 650); // Wait for flip animation to complete

            // Fetch and render back side
            const backEl = document.getElementById(`${cardId}-back`);
            
            // Check if content is already loaded (from cache or previous flip)
            const hasContent = backEl.querySelector('.back-content') !== null;
            
            if (hasContent) {
                // Content already loaded, no need to fetch again
                return;
            }
            
            try {
                const jobs = await fetchJobDetails(runId);
                const details = parseDetailedStatus(jobs);
                
                // Get run info
                const runs = JSON.parse(sessionStorage.getItem('cachedRuns') || '[]');
                const run = runs.find(r => r.id === runId);
                
                // Get the actual job URL (not just run URL)
                const updateJob = jobs?.find(j => j.name === 'update');
                const jobUrl = updateJob?.html_url || run?.html_url;

                backEl.innerHTML = `
                    <div class="back-content">
                        <div class="back-header">
                            <div class="back-status">
                                <span class="status-icon-large">${details.statusIcon}</span>
                                <span>${details.actualStatus}</span>
                            </div>
                            <span style="font-size: 0.9rem; color: #9ca3af;">#${run?.run_number || '?'}</span>
                        </div>

                        <div class="back-details">
                            <div class="detail-row">
                                <span class="detail-label">Workflow:</span>
                                <span class="detail-value">${run?.name || 'Unknown'}</span>
                            </div>
                            <div class="detail-row">
                                <span class="detail-label">Triggered:</span>
                                <span class="detail-value">${formatRelativeTime(run?.created_at)}</span>
                            </div>
                            <div class="detail-row">
                                <span class="detail-label">Duration:</span>
                                <span class="detail-value">${formatDuration(run?.updated_at && run?.created_at ? new Date(run.updated_at) - new Date(run.created_at) : null)}</span>
                            </div>
                        </div>

                        <div class="${details.statusClass}">
                            <strong>${details.actualStatus}</strong>
                            <p style="margin-top: 8px; margin-bottom: 0;">${details.description}</p>
                            ${details.errorInfo ? `<p style="margin-top: 8px; margin-bottom: 0; font-size: 0.85rem;"><strong>Details:</strong> ${details.errorInfo}</p>` : ''}
                        </div>

                        <div style="text-align: center; margin-top: 5px; font-size: 0.8rem; color: #6b7280;">
                            üí° Tip: Click card to flip back
                        </div>

                        <div class="back-footer" style="justify-content: center;">
                            <button class="back-btn btn-primary" onclick="event.stopPropagation(); window.open('${jobUrl}', '_blank')" title="Open job logs directly on GitHub" style="width: auto; padding: 12px 24px;">
                                üìã View Complete Logs ‚Üí
                            </button>
                        </div>
                    </div>
                `;
            } catch (error) {
                backEl.innerHTML = `
                    <div class="back-content">
                        <div class="error-box">
                            <strong>Error Loading Details</strong>
                            <p style="margin-top: 8px;">${error.message}</p>
                        </div>
                        <div style="text-align: center; margin-top: 15px; font-size: 0.85rem; color: #9ca3af;">
                            üí° Click card to flip back
                        </div>
                    </div>
                `;
            }
        }

        // Calculate statistics
        function calculateStats(runs) {
            const total = runs.length;
            const successful = runs.filter(r => r.conclusion === 'success').length;
            const successRate = total > 0 ? Math.round((successful / total) * 100) : 0;
            
            const lastRun = runs[0];
            let lastStatus = 'N/A';
            if (lastRun) {
                const status = getStatusText(lastRun.status, lastRun.conclusion);
                lastStatus = status.charAt(0).toUpperCase() + status.slice(1);
            }

            return { total, successRate, lastStatus };
        }

        // Update stats display
        function updateStats(runs) {
            const stats = calculateStats(runs);
            document.getElementById('totalRuns').textContent = stats.total;
            document.getElementById('successRate').textContent = `${stats.successRate}%`;
            document.getElementById('lastRun').textContent = stats.lastStatus;
        }

        // Fetch and display runs
        async function loadRuns() {
            const contentDiv = document.getElementById('content');
            const refreshBtn = document.getElementById('refreshBtn');
            
            // Disable refresh button
            refreshBtn.disabled = true;
            
            // Show loading
            contentDiv.innerHTML = `
                <div class="loading">
                    <div class="spinner"></div>
                    <p>Loading workflow runs...</p>
                </div>
            `;

            try {
                const response = await fetch(API_URL);
                updateRateLimit(response);
                
                if (!response.ok) {
                    if (response.status === 403) {
                        // Check if it's rate limit
                        const resetTime = rateLimitReset ? new Date(rateLimitReset).toLocaleTimeString() : 'in about an hour';
                        const minutesUntilReset = rateLimitReset ? Math.ceil((rateLimitReset - new Date()) / 60000) : 60;
                        
                        throw new Error(
                            `GitHub API rate limit exceeded (60 requests/hour).\n\n` +
                            `Rate limit resets at: ${resetTime} (in ~${minutesUntilReset} minutes)\n\n` +
                            `Tips to avoid this:\n` +
                            `‚Ä¢ Don't refresh too frequently\n` +
                            `‚Ä¢ Avoid clicking too many cards at once\n` +
                            `‚Ä¢ Wait for the rate limit to reset`
                        );
                    }
                    throw new Error(`API Error: ${response.status} ${response.statusText}`);
                }

                const data = await response.json();
                let runs = data.workflow_runs || [];

                // Filter to only show "Update Naukri Profile" workflow runs
                runs = runs.filter(run => run.name === 'Update Naukri Profile');

                if (runs.length === 0) {
                    const allRunNames = data.workflow_runs.map(r => r.name).join(', ');
                    contentDiv.innerHTML = `
                        <div class="empty-state">
                            <h3>No "Update Naukri Profile" runs found</h3>
                            <p>Looking for workflow runs with name "Update Naukri Profile".</p>
                            ${data.workflow_runs.length > 0 ? `<p style="margin-top: 10px; font-size: 0.9rem; color: #9ca3af;">Found ${data.workflow_runs.length} other workflow(s): ${allRunNames}</p>` : ''}
                            <p style="margin-top: 15px;">Runs will appear here once the workflow executes.</p>
                        </div>
                    `;
                } else {
                    // Sort runs by creation date (most recent first)
                    runs.sort((a, b) => new Date(b.created_at) - new Date(a.created_at));

                    // Store runs in session storage for card flip access
                    sessionStorage.setItem('cachedRuns', JSON.stringify(runs));

                    // Update stats
                    updateStats(runs);

                    // Create runs grid (synchronous now)
                    const runsHTML = runs.map((run, index) => createRunCard(run, index)).join('');
                    contentDiv.innerHTML = `<div class="runs-grid">${runsHTML}</div>`;

                    // Update last updated time
                    document.getElementById('lastUpdated').textContent = new Date().toLocaleTimeString();
                    
                    // Update rate limit display
                    updateRateLimitDisplay();
                    
                    // Show warning if rate limit is low
                    if (rateLimitRemaining < 10 && rateLimitRemaining > 0) {
                        const warningEl = document.createElement('div');
                        warningEl.style.cssText = 'position: fixed; top: 20px; right: 20px; background: rgba(251, 191, 36, 0.9); color: #000; padding: 15px 20px; border-radius: 8px; box-shadow: 0 4px 12px rgba(0,0,0,0.3); z-index: 1000; max-width: 300px;';
                        warningEl.innerHTML = `
                            <strong>‚ö†Ô∏è Low API Calls</strong>
                            <p style="margin: 8px 0 0 0; font-size: 0.9rem;">Only ${rateLimitRemaining} API calls left. Avoid refreshing or clicking too many cards.</p>
                        `;
                        document.body.appendChild(warningEl);
                        setTimeout(() => warningEl.remove(), 5000);
                    }
                }
            } catch (error) {
                console.error('Error loading runs:', error);
                
                const isRateLimit = error.message.includes('rate limit');
                const errorTitle = isRateLimit ? '‚è±Ô∏è Rate Limit Exceeded' : '‚ùå Failed to Load Runs';
                
                contentDiv.innerHTML = `
                    <div class="error">
                        <h3>${errorTitle}</h3>
                        <p style="white-space: pre-line;">${error.message}</p>
                        ${isRateLimit ? `
                            <div style="margin-top: 20px; padding: 15px; background: rgba(251, 191, 36, 0.1); border: 1px solid rgba(251, 191, 36, 0.3); border-radius: 8px;">
                                <strong style="color: #fbbf24;">üí° Why did this happen?</strong>
                                <p style="margin-top: 8px; color: #e0e0e0;">
                                    The dashboard uses GitHub's public API which limits unauthenticated requests to 60 per hour per IP address. 
                                    Each page refresh uses 1 call, and each card flip uses 1 call.
                                </p>
                                <p style="margin-top: 8px; color: #e0e0e0;">
                                    <strong>Solution:</strong> Wait for the rate limit to reset (shown above), then you can use the dashboard again!
                                </p>
                            </div>
                        ` : `
                            <p style="margin-top: 15px;">
                                <small>Make sure the repository is public or check the console for more details.</small>
                            </p>
                        `}
                    </div>
                `;
                
                // Update rate limit display even on error
                if (rateLimitRemaining !== null) {
                    updateRateLimitDisplay();
                }
            } finally {
                // Re-enable refresh button
                refreshBtn.disabled = false;
            }
        }

        // Load runs on page load
        document.addEventListener('DOMContentLoaded', loadRuns);
    </script>
</body>
</html>

